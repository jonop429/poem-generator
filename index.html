<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Poem Forms</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body { font-family:sans-serif; max-width:800px; margin:2rem auto; padding:1rem; }
p { font-size: smaller; }
select {
  padding: 0.5rem 0.75rem;    /* space INSIDE the button */
  margin-bottom: 1.25rem;    /* space BELOW the menu */
}
input { display:block; width:100%; margin-bottom:0.25rem; margin-top:0.25rem; padding:0.5rem; }
.obverse-row {
  display: flex;
  align-items: center;
  gap: 0.25rem;          /* replaces visual spacing */
}

.obverse-input {
  width: 100%;           /* same as Paradelle */
  flex: none;            /* critical: disable stretch */
}

button { padding:0.5rem 1rem; margin:0.25rem 0.25rem 0.25rem 0; cursor:pointer; }
button.small { font-size: 0.85rem; padding:0.25rem 0.5rem; margin:0.25rem 0.25rem 0.25rem 0.25rem;}
.poem { background:#f9f9f9; padding:1rem; border:1px solid #ccc; white-space:pre-wrap; margin-top:1rem; }
.word { display:inline-block; margin:2px; padding:4px 6px; background:#f0f0f0; border:1px solid #ccc; cursor:move; user-select:none; }
</style>
</head>
<body>

<h1 id="title"></h1>
<p id="info"></p>

<div id="input-section"></div>

<div id="output-section" style="display:none;">
  <div class="poem" id="poem"></div>
  <button id="backBtn">Back to form</button>
  <button id="shuffleBtn">Shuffle</button>
  <button id="togglePlainBtn">View as Plain Text</button>
</div>

<script>
const titleEl = document.getElementById("title");
const infoEl = document.getElementById("info");
const inputSection = document.getElementById("input-section");
const outputSection = document.getElementById("output-section");
const poemDiv = document.getElementById("poem");
const backBtn = document.getElementById("backBtn");
const shuffleBtn = document.getElementById("shuffleBtn");
const togglePlainBtn = document.getElementById("togglePlainBtn");

let inputLines = [];
let thesisQuestion = "";
let interactiveLines = {};
let isReverseMode = false;
let showPlainText = false;
let currentForm = "paradelle"; // "paradelle" or "obverse"

// --- Utilities ---
const extractWords = (text) => text.match(/[A-Za-z0-9'-]+/g) || [];
const shuffleArray = arr => { for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } };
const renderLine = line => { const div = document.createElement("div"); div.textContent = line; return div; };

// Word-level draggable line (Paradelle only)
const renderInteractiveLine = key => {
  const lineDiv = document.createElement("div");
  interactiveLines[key].forEach((word, idx)=>{
    const span=document.createElement("span");
    span.className="word"; span.draggable=true; span.textContent=word;
    span.ondragstart = e => { e.dataTransfer.setData("fromKey", key); e.dataTransfer.setData("fromIdx", idx); };
    span.ondrop = e => {
      e.preventDefault();
      const fromKey = e.dataTransfer.getData("fromKey");
      const fromIdx = +e.dataTransfer.getData("fromIdx");
      if(!(fromKey in interactiveLines)) return;
      const moved = interactiveLines[fromKey].splice(fromIdx,1)[0];
      interactiveLines[key].splice(idx,0,moved);
      if(isReverseMode) updateMirroredLines();
      renderPoem();
    };
    span.ondragover = e=>e.preventDefault();
    lineDiv.appendChild(span);
  });
  return lineDiv;
};

// --- Paradelle Logic ---
const updateMirroredLines = () => {
  interactiveLines["s1l2"] = [...interactiveLines["s1l1"]];
  interactiveLines["s1l4"] = [...interactiveLines["s1l3"]];
  interactiveLines["s2l2"] = [...interactiveLines["s2l1"]];
  interactiveLines["s2l4"] = [...interactiveLines["s2l3"]];
  interactiveLines["s3l2"] = [...interactiveLines["s3l1"]];
  interactiveLines["s3l4"] = [...interactiveLines["s3l3"]];
};

const scrambleSix = text => {
  const words = extractWords(text); shuffleArray(words);
  const result=[]; let start=0; const baseSize=Math.floor(words.length/6); let rem=words.length%6;
  for(let i=0;i<6;i++){ let size=baseSize+(rem>0?1:0); rem--; result.push(words.slice(start,start+size)); start+=size; }
  return result;
};

const prepareParadelle = reverse => {
  const [l1,l2,l3,l4,l5,l6] = inputLines;
  interactiveLines={};
  if(!reverse){
    interactiveLines["s1l1"]=extractWords(l1); interactiveLines["s1l2"]=extractWords(l1);
    interactiveLines["s1l3"]=extractWords(l2); interactiveLines["s1l4"]=extractWords(l2);
    interactiveLines["s1l5"]=extractWords(l1); shuffleArray(interactiveLines["s1l5"]);
    interactiveLines["s1l6"]=extractWords(l2); shuffleArray(interactiveLines["s1l6"]);
    interactiveLines["s2l1"]=extractWords(l3); interactiveLines["s2l2"]=extractWords(l3);
    interactiveLines["s2l3"]=extractWords(l4); interactiveLines["s2l4"]=extractWords(l4);
    interactiveLines["s2l5"]=extractWords(l3); shuffleArray(interactiveLines["s2l5"]);
    interactiveLines["s2l6"]=extractWords(l4); shuffleArray(interactiveLines["s2l6"]);
    interactiveLines["s3l1"]=extractWords(l5); interactiveLines["s3l2"]=extractWords(l5);
    interactiveLines["s3l3"]=extractWords(l6); interactiveLines["s3l4"]=extractWords(l6);
    interactiveLines["s3l5"]=extractWords(l5); shuffleArray(interactiveLines["s3l5"]);
    interactiveLines["s3l6"]=extractWords(l6); shuffleArray(interactiveLines["s3l6"]);
  } else {
    const s1 = extractWords(`${l1} ${l2}`); shuffleArray(s1); const mid1=Math.ceil(s1.length/2);
    interactiveLines["s1l1"]=s1.slice(0,mid1); interactiveLines["s1l3"]=s1.slice(mid1); interactiveLines["s1l5"]=extractWords(l1); interactiveLines["s1l6"]=extractWords(l2);
    const s2 = extractWords(`${l3} ${l4}`); shuffleArray(s2); const mid2=Math.ceil(s2.length/2);
    interactiveLines["s2l1"]=s2.slice(0,mid2); interactiveLines["s2l3"]=s2.slice(mid2); interactiveLines["s2l5"]=extractWords(l3); interactiveLines["s2l6"]=extractWords(l4);
    const s3 = extractWords(`${l5} ${l6}`); shuffleArray(s3); const mid3=Math.ceil(s3.length/2);
    interactiveLines["s3l1"]=s3.slice(0,mid3); interactiveLines["s3l3"]=s3.slice(mid3); interactiveLines["s3l5"]=extractWords(l5); interactiveLines["s3l6"]=extractWords(l6);
    updateMirroredLines();
  }
  const allWords = inputLines.join(" "); scrambleSix(allWords).forEach((arr,i)=>interactiveLines[`f${i}`]=arr);
};

// --- Obverse Logic ---
const prepareObverse = reverse => {
  const trimmed = inputLines.map(l=>l.trim()).filter(l=>l.length);
  const first = reverse ? [...trimmed].reverse() : trimmed;
  const second = reverse ? trimmed : [...trimmed].reverse();
  interactiveLines={};
  first.forEach((line,i)=>interactiveLines[`s1l${i+1}`]=[line]);
  second.forEach((line,i)=>interactiveLines[`s2l${i+1}`]=[line]);
  interactiveLines["thesis"] = [thesisQuestion.replace(/\?*$/,"")+"?"];
};

// --- Render Poem ---
const renderPoem = () => {
  poemDiv.innerHTML="";
  if(currentForm==="paradelle"){
    for(let stanza=1;stanza<=3;stanza++){
      for(let ln=1;ln<=6;ln++){
        const key=`s${stanza}l${ln}`; if(!interactiveLines[key]) continue;
        if(showPlainText){ poemDiv.appendChild(renderLine(interactiveLines[key].join(" "))); }
        else{ if(isReverseMode&&[1,3].includes(ln)||!isReverseMode&&[5,6].includes(ln)) poemDiv.appendChild(renderInteractiveLine(key));
        else poemDiv.appendChild(renderLine(interactiveLines[key].join(" "))); }
      } poemDiv.appendChild(document.createElement("br"));
    }
    poemDiv.appendChild(document.createElement("br"));
    for(let i=0;i<6;i++){ const k=`f${i}`; if(interactiveLines[k]) poemDiv.appendChild(showPlainText?renderLine(interactiveLines[k].join(" ")):renderInteractiveLine(k)); }
  } else if(currentForm==="obverse"){
    ["s1","s2"].forEach(stanza=>{
      Object.keys(interactiveLines).filter(k=>k.startsWith(stanza)).forEach(k=>{
        poemDiv.appendChild(renderLine(interactiveLines[k][0]));
      });
      poemDiv.appendChild(document.createElement("br"));
    });
    poemDiv.appendChild(renderLine(interactiveLines["thesis"][0]));
  }

  // Hide buttons for Obverse
  if(currentForm === "obverse") {
    shuffleBtn.style.display = "none";
    togglePlainBtn.style.display = "none";
  } else {
    shuffleBtn.style.display = "inline-block";
    togglePlainBtn.style.display = "inline-block";
  }

};

// --- UI Handlers ---
const generateInputs = () => {
  inputSection.innerHTML = "";

  // --- INITIALIZE INPUT LINES SAFELY ---
  if (currentForm === "paradelle") {
    inputLines = Array(6).fill("");
  }

  if (currentForm === "obverse" && inputLines.length === 0) {
    inputLines = Array(4).fill("");
  }

  // --- RENDER INPUT LINES ---
  inputLines.forEach((l, i) => {

    // OBVERSE: wrapped row with +/- buttons
    if (currentForm === "obverse") {
      const row = document.createElement("div");
      row.className = "input-row obverse-row";

      const inp = document.createElement("input");
      inp.placeholder = `Enter line ${i + 1}`;
      inp.value = l;
      inp.oninput = e => inputLines[i] = e.target.value;
      inp.classList.add("obverse-input");  // narrower width
      row.appendChild(inp);

      const addBtn = document.createElement("button");
      addBtn.textContent = "+";
      addBtn.onclick = () => {
        inputLines.splice(i + 1, 0, "");
        generateInputs();
      };
      row.appendChild(addBtn);

      const delBtn = document.createElement("button");
      delBtn.textContent = "âˆ’";
      delBtn.onclick = () => {
        if (inputLines.length > 1) {
          inputLines.splice(i, 1);
          generateInputs();
        }
      };
      row.appendChild(delBtn);

      addBtn.classList.add("small");
      delBtn.classList.add("small");

      inputSection.appendChild(row);
    }

    // PARADELLE: plain inputs only
    else {
      const inp = document.createElement("input");
      inp.placeholder = `Enter line ${i + 1}`;
      inp.value = l;
      inp.oninput = e => inputLines[i] = e.target.value;
      inputSection.appendChild(inp);
    }
  });

  // --- OBVERSE THESIS QUESTION ---
  if (currentForm === "obverse") {
    const thesisWrapper = document.createElement("div");
    thesisWrapper.style.display = "flex";
    thesisWrapper.style.alignItems = "center";
    thesisWrapper.style.marginTop = "1rem";

    const thesisInput = document.createElement("input");
    thesisInput.placeholder = "Thesis question";
    thesisInput.value = thesisQuestion;
    thesisInput.oninput = e => thesisQuestion = e.target.value;
    thesisInput.style.flex = "1";

    const qMark = document.createElement("span");
    qMark.textContent = "?";
    qMark.style.marginLeft = "0.25rem";
    qMark.style.fontSize = "1.25rem";

    thesisWrapper.appendChild(thesisInput);
    thesisWrapper.appendChild(qMark);
    inputSection.appendChild(thesisWrapper);
  }

  // --- GENERATE BUTTONS (UNCHANGED) ---
  const btn = document.createElement("button");
  btn.textContent = `Generate ${currentForm}`;
  btn.onclick = () => {
    isReverseMode = false;
    outputSection.style.display = "block";
    inputSection.style.display = "none";
    menu.style.display = "none";
    currentForm === "paradelle" ? prepareParadelle(false) : prepareObverse(false);
    renderPoem();
  };

  const btnRev = document.createElement("button");
  btnRev.textContent = "Generate in reverse";
  btnRev.onclick = () => {
    isReverseMode = true;
    outputSection.style.display = "block";
    inputSection.style.display = "none";
    menu.style.display = "none";
    currentForm === "paradelle" ? prepareParadelle(true) : prepareObverse(true);
    renderPoem();
  };

  inputSection.appendChild(btn);
  inputSection.appendChild(btnRev);
};

backBtn.onclick=()=>{outputSection.style.display="none"; inputSection.style.display="block"; menu.style.display = "block"; showPlainText=false;};
shuffleBtn.onclick=()=>{
  if(currentForm==="paradelle"){
    const keys=!isReverseMode?["s1l5","s1l6","s2l5","s2l6","s3l5","s3l6"]:["s1l1","s1l3","s2l1","s2l3","s3l1","s3l3"];
    keys.forEach(k=>interactiveLines[k]&&shuffleArray(interactiveLines[k]));
    for(let i=0;i<6;i++){interactiveLines[`f${i}`]&&shuffleArray(interactiveLines[`f${i}`]);}
    if(isReverseMode) updateMirroredLines();
    renderPoem();
  }
};
togglePlainBtn.onclick=()=>{showPlainText=!showPlainText; togglePlainBtn.textContent=showPlainText?"View as Interactive":"View as Plain Text"; renderPoem();};

// --- Form Selection ---
const forms = {
  paradelle: {title:"Paradelle", info:"A paradelle is a poetic form involving repetition and rearrangement. Billy Collins invented it in \"Paradelle for Susan\" for his 1998 book, \"Picnic, Lightning,\" but claimed that it was an 11th century French form. The prank successfully prompted a paradelle revival before Collins admitted in 2002 that he made it up."},
  obverse: {title:"Obverse", info:"The obverse was created by Nicole Sealey for her poem \"Candelabra with Heads\" in her 2017 debut, \"Ordinary Beast.\" Inputs are mirrored into two stanzas, followed by a thesis question."}
};
const menu = document.createElement("select");
Object.keys(forms).forEach(k=>{const o=document.createElement("option"); o.value=k; o.textContent=forms[k].title; menu.appendChild(o);});
menu.onchange=e=>{currentForm=e.target.value; titleEl.textContent=forms[currentForm].title; infoEl.textContent=forms[currentForm].info; generateInputs();};
document.body.insertBefore(menu, inputSection);

titleEl.textContent=forms[currentForm].title; infoEl.textContent=forms[currentForm].info;
generateInputs();

</script>
</body>
</html>
